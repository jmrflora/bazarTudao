// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/jmrflora/bazarTudao/ent/cliente"
	"github.com/jmrflora/bazarTudao/ent/envio"
	"github.com/jmrflora/bazarTudao/ent/itemordem"
	"github.com/jmrflora/bazarTudao/ent/ordem"
	"github.com/jmrflora/bazarTudao/ent/predicate"
	"github.com/jmrflora/bazarTudao/ent/produto"
	"github.com/jmrflora/bazarTudao/ent/stock"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCliente   = "Cliente"
	TypeEnvio     = "Envio"
	TypeItemOrdem = "ItemOrdem"
	TypeOrdem     = "Ordem"
	TypeProduto   = "Produto"
	TypeStock     = "Stock"
)

// ClienteMutation represents an operation that mutates the Cliente nodes in the graph.
type ClienteMutation struct {
	config
	op            Op
	typ           string
	id            *int
	email         *string
	nome          *string
	cpf           *string
	telefone      *string
	clearedFields map[string]struct{}
	ordens        map[int]struct{}
	removedordens map[int]struct{}
	clearedordens bool
	done          bool
	oldValue      func(context.Context) (*Cliente, error)
	predicates    []predicate.Cliente
}

var _ ent.Mutation = (*ClienteMutation)(nil)

// clienteOption allows management of the mutation configuration using functional options.
type clienteOption func(*ClienteMutation)

// newClienteMutation creates new mutation for the Cliente entity.
func newClienteMutation(c config, op Op, opts ...clienteOption) *ClienteMutation {
	m := &ClienteMutation{
		config:        c,
		op:            op,
		typ:           TypeCliente,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClienteID sets the ID field of the mutation.
func withClienteID(id int) clienteOption {
	return func(m *ClienteMutation) {
		var (
			err   error
			once  sync.Once
			value *Cliente
		)
		m.oldValue = func(ctx context.Context) (*Cliente, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cliente.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCliente sets the old Cliente of the mutation.
func withCliente(node *Cliente) clienteOption {
	return func(m *ClienteMutation) {
		m.oldValue = func(context.Context) (*Cliente, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClienteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClienteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClienteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClienteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cliente.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *ClienteMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ClienteMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Cliente entity.
// If the Cliente object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClienteMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *ClienteMutation) ResetEmail() {
	m.email = nil
}

// SetNome sets the "nome" field.
func (m *ClienteMutation) SetNome(s string) {
	m.nome = &s
}

// Nome returns the value of the "nome" field in the mutation.
func (m *ClienteMutation) Nome() (r string, exists bool) {
	v := m.nome
	if v == nil {
		return
	}
	return *v, true
}

// OldNome returns the old "nome" field's value of the Cliente entity.
// If the Cliente object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClienteMutation) OldNome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNome: %w", err)
	}
	return oldValue.Nome, nil
}

// ResetNome resets all changes to the "nome" field.
func (m *ClienteMutation) ResetNome() {
	m.nome = nil
}

// SetCpf sets the "cpf" field.
func (m *ClienteMutation) SetCpf(s string) {
	m.cpf = &s
}

// Cpf returns the value of the "cpf" field in the mutation.
func (m *ClienteMutation) Cpf() (r string, exists bool) {
	v := m.cpf
	if v == nil {
		return
	}
	return *v, true
}

// OldCpf returns the old "cpf" field's value of the Cliente entity.
// If the Cliente object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClienteMutation) OldCpf(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCpf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCpf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCpf: %w", err)
	}
	return oldValue.Cpf, nil
}

// ResetCpf resets all changes to the "cpf" field.
func (m *ClienteMutation) ResetCpf() {
	m.cpf = nil
}

// SetTelefone sets the "telefone" field.
func (m *ClienteMutation) SetTelefone(s string) {
	m.telefone = &s
}

// Telefone returns the value of the "telefone" field in the mutation.
func (m *ClienteMutation) Telefone() (r string, exists bool) {
	v := m.telefone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelefone returns the old "telefone" field's value of the Cliente entity.
// If the Cliente object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClienteMutation) OldTelefone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelefone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelefone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelefone: %w", err)
	}
	return oldValue.Telefone, nil
}

// ResetTelefone resets all changes to the "telefone" field.
func (m *ClienteMutation) ResetTelefone() {
	m.telefone = nil
}

// AddOrdenIDs adds the "ordens" edge to the Ordem entity by ids.
func (m *ClienteMutation) AddOrdenIDs(ids ...int) {
	if m.ordens == nil {
		m.ordens = make(map[int]struct{})
	}
	for i := range ids {
		m.ordens[ids[i]] = struct{}{}
	}
}

// ClearOrdens clears the "ordens" edge to the Ordem entity.
func (m *ClienteMutation) ClearOrdens() {
	m.clearedordens = true
}

// OrdensCleared reports if the "ordens" edge to the Ordem entity was cleared.
func (m *ClienteMutation) OrdensCleared() bool {
	return m.clearedordens
}

// RemoveOrdenIDs removes the "ordens" edge to the Ordem entity by IDs.
func (m *ClienteMutation) RemoveOrdenIDs(ids ...int) {
	if m.removedordens == nil {
		m.removedordens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ordens, ids[i])
		m.removedordens[ids[i]] = struct{}{}
	}
}

// RemovedOrdens returns the removed IDs of the "ordens" edge to the Ordem entity.
func (m *ClienteMutation) RemovedOrdensIDs() (ids []int) {
	for id := range m.removedordens {
		ids = append(ids, id)
	}
	return
}

// OrdensIDs returns the "ordens" edge IDs in the mutation.
func (m *ClienteMutation) OrdensIDs() (ids []int) {
	for id := range m.ordens {
		ids = append(ids, id)
	}
	return
}

// ResetOrdens resets all changes to the "ordens" edge.
func (m *ClienteMutation) ResetOrdens() {
	m.ordens = nil
	m.clearedordens = false
	m.removedordens = nil
}

// Where appends a list predicates to the ClienteMutation builder.
func (m *ClienteMutation) Where(ps ...predicate.Cliente) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClienteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClienteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cliente, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClienteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClienteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cliente).
func (m *ClienteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClienteMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.email != nil {
		fields = append(fields, cliente.FieldEmail)
	}
	if m.nome != nil {
		fields = append(fields, cliente.FieldNome)
	}
	if m.cpf != nil {
		fields = append(fields, cliente.FieldCpf)
	}
	if m.telefone != nil {
		fields = append(fields, cliente.FieldTelefone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClienteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cliente.FieldEmail:
		return m.Email()
	case cliente.FieldNome:
		return m.Nome()
	case cliente.FieldCpf:
		return m.Cpf()
	case cliente.FieldTelefone:
		return m.Telefone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClienteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cliente.FieldEmail:
		return m.OldEmail(ctx)
	case cliente.FieldNome:
		return m.OldNome(ctx)
	case cliente.FieldCpf:
		return m.OldCpf(ctx)
	case cliente.FieldTelefone:
		return m.OldTelefone(ctx)
	}
	return nil, fmt.Errorf("unknown Cliente field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClienteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cliente.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case cliente.FieldNome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNome(v)
		return nil
	case cliente.FieldCpf:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCpf(v)
		return nil
	case cliente.FieldTelefone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelefone(v)
		return nil
	}
	return fmt.Errorf("unknown Cliente field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClienteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClienteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClienteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cliente numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClienteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClienteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClienteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cliente nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClienteMutation) ResetField(name string) error {
	switch name {
	case cliente.FieldEmail:
		m.ResetEmail()
		return nil
	case cliente.FieldNome:
		m.ResetNome()
		return nil
	case cliente.FieldCpf:
		m.ResetCpf()
		return nil
	case cliente.FieldTelefone:
		m.ResetTelefone()
		return nil
	}
	return fmt.Errorf("unknown Cliente field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClienteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ordens != nil {
		edges = append(edges, cliente.EdgeOrdens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClienteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cliente.EdgeOrdens:
		ids := make([]ent.Value, 0, len(m.ordens))
		for id := range m.ordens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClienteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedordens != nil {
		edges = append(edges, cliente.EdgeOrdens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClienteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cliente.EdgeOrdens:
		ids := make([]ent.Value, 0, len(m.removedordens))
		for id := range m.removedordens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClienteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedordens {
		edges = append(edges, cliente.EdgeOrdens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClienteMutation) EdgeCleared(name string) bool {
	switch name {
	case cliente.EdgeOrdens:
		return m.clearedordens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClienteMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Cliente unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClienteMutation) ResetEdge(name string) error {
	switch name {
	case cliente.EdgeOrdens:
		m.ResetOrdens()
		return nil
	}
	return fmt.Errorf("unknown Cliente edge %s", name)
}

// EnvioMutation represents an operation that mutates the Envio nodes in the graph.
type EnvioMutation struct {
	config
	op            Op
	typ           string
	id            *int
	data          *time.Time
	clearedFields map[string]struct{}
	itens         map[int]struct{}
	removeditens  map[int]struct{}
	cleareditens  bool
	done          bool
	oldValue      func(context.Context) (*Envio, error)
	predicates    []predicate.Envio
}

var _ ent.Mutation = (*EnvioMutation)(nil)

// envioOption allows management of the mutation configuration using functional options.
type envioOption func(*EnvioMutation)

// newEnvioMutation creates new mutation for the Envio entity.
func newEnvioMutation(c config, op Op, opts ...envioOption) *EnvioMutation {
	m := &EnvioMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvio,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvioID sets the ID field of the mutation.
func withEnvioID(id int) envioOption {
	return func(m *EnvioMutation) {
		var (
			err   error
			once  sync.Once
			value *Envio
		)
		m.oldValue = func(ctx context.Context) (*Envio, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Envio.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvio sets the old Envio of the mutation.
func withEnvio(node *Envio) envioOption {
	return func(m *EnvioMutation) {
		m.oldValue = func(context.Context) (*Envio, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvioMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvioMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvioMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvioMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Envio.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetData sets the "data" field.
func (m *EnvioMutation) SetData(t time.Time) {
	m.data = &t
}

// Data returns the value of the "data" field in the mutation.
func (m *EnvioMutation) Data() (r time.Time, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Envio entity.
// If the Envio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvioMutation) OldData(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *EnvioMutation) ResetData() {
	m.data = nil
}

// AddItenIDs adds the "itens" edge to the ItemOrdem entity by ids.
func (m *EnvioMutation) AddItenIDs(ids ...int) {
	if m.itens == nil {
		m.itens = make(map[int]struct{})
	}
	for i := range ids {
		m.itens[ids[i]] = struct{}{}
	}
}

// ClearItens clears the "itens" edge to the ItemOrdem entity.
func (m *EnvioMutation) ClearItens() {
	m.cleareditens = true
}

// ItensCleared reports if the "itens" edge to the ItemOrdem entity was cleared.
func (m *EnvioMutation) ItensCleared() bool {
	return m.cleareditens
}

// RemoveItenIDs removes the "itens" edge to the ItemOrdem entity by IDs.
func (m *EnvioMutation) RemoveItenIDs(ids ...int) {
	if m.removeditens == nil {
		m.removeditens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.itens, ids[i])
		m.removeditens[ids[i]] = struct{}{}
	}
}

// RemovedItens returns the removed IDs of the "itens" edge to the ItemOrdem entity.
func (m *EnvioMutation) RemovedItensIDs() (ids []int) {
	for id := range m.removeditens {
		ids = append(ids, id)
	}
	return
}

// ItensIDs returns the "itens" edge IDs in the mutation.
func (m *EnvioMutation) ItensIDs() (ids []int) {
	for id := range m.itens {
		ids = append(ids, id)
	}
	return
}

// ResetItens resets all changes to the "itens" edge.
func (m *EnvioMutation) ResetItens() {
	m.itens = nil
	m.cleareditens = false
	m.removeditens = nil
}

// Where appends a list predicates to the EnvioMutation builder.
func (m *EnvioMutation) Where(ps ...predicate.Envio) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvioMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvioMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Envio, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvioMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvioMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Envio).
func (m *EnvioMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvioMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.data != nil {
		fields = append(fields, envio.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvioMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case envio.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvioMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case envio.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Envio field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvioMutation) SetField(name string, value ent.Value) error {
	switch name {
	case envio.FieldData:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Envio field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvioMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvioMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvioMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Envio numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvioMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvioMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvioMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Envio nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvioMutation) ResetField(name string) error {
	switch name {
	case envio.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Envio field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvioMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.itens != nil {
		edges = append(edges, envio.EdgeItens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvioMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case envio.EdgeItens:
		ids := make([]ent.Value, 0, len(m.itens))
		for id := range m.itens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvioMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeditens != nil {
		edges = append(edges, envio.EdgeItens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvioMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case envio.EdgeItens:
		ids := make([]ent.Value, 0, len(m.removeditens))
		for id := range m.removeditens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvioMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareditens {
		edges = append(edges, envio.EdgeItens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvioMutation) EdgeCleared(name string) bool {
	switch name {
	case envio.EdgeItens:
		return m.cleareditens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvioMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Envio unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvioMutation) ResetEdge(name string) error {
	switch name {
	case envio.EdgeItens:
		m.ResetItens()
		return nil
	}
	return fmt.Errorf("unknown Envio edge %s", name)
}

// ItemOrdemMutation represents an operation that mutates the ItemOrdem nodes in the graph.
type ItemOrdemMutation struct {
	config
	op                Op
	typ               string
	id                *int
	quantidade        *int
	addquantidade     *int
	preco_unitario    *float64
	addpreco_unitario *float64
	preco_total       *float64
	addpreco_total    *float64
	clearedFields     map[string]struct{}
	ordem             *int
	clearedordem      bool
	produto           *int
	clearedproduto    bool
	envio             *int
	clearedenvio      bool
	done              bool
	oldValue          func(context.Context) (*ItemOrdem, error)
	predicates        []predicate.ItemOrdem
}

var _ ent.Mutation = (*ItemOrdemMutation)(nil)

// itemordemOption allows management of the mutation configuration using functional options.
type itemordemOption func(*ItemOrdemMutation)

// newItemOrdemMutation creates new mutation for the ItemOrdem entity.
func newItemOrdemMutation(c config, op Op, opts ...itemordemOption) *ItemOrdemMutation {
	m := &ItemOrdemMutation{
		config:        c,
		op:            op,
		typ:           TypeItemOrdem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemOrdemID sets the ID field of the mutation.
func withItemOrdemID(id int) itemordemOption {
	return func(m *ItemOrdemMutation) {
		var (
			err   error
			once  sync.Once
			value *ItemOrdem
		)
		m.oldValue = func(ctx context.Context) (*ItemOrdem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ItemOrdem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItemOrdem sets the old ItemOrdem of the mutation.
func withItemOrdem(node *ItemOrdem) itemordemOption {
	return func(m *ItemOrdemMutation) {
		m.oldValue = func(context.Context) (*ItemOrdem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemOrdemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemOrdemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemOrdemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemOrdemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ItemOrdem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantidade sets the "quantidade" field.
func (m *ItemOrdemMutation) SetQuantidade(i int) {
	m.quantidade = &i
	m.addquantidade = nil
}

// Quantidade returns the value of the "quantidade" field in the mutation.
func (m *ItemOrdemMutation) Quantidade() (r int, exists bool) {
	v := m.quantidade
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantidade returns the old "quantidade" field's value of the ItemOrdem entity.
// If the ItemOrdem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemOrdemMutation) OldQuantidade(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantidade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantidade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantidade: %w", err)
	}
	return oldValue.Quantidade, nil
}

// AddQuantidade adds i to the "quantidade" field.
func (m *ItemOrdemMutation) AddQuantidade(i int) {
	if m.addquantidade != nil {
		*m.addquantidade += i
	} else {
		m.addquantidade = &i
	}
}

// AddedQuantidade returns the value that was added to the "quantidade" field in this mutation.
func (m *ItemOrdemMutation) AddedQuantidade() (r int, exists bool) {
	v := m.addquantidade
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantidade resets all changes to the "quantidade" field.
func (m *ItemOrdemMutation) ResetQuantidade() {
	m.quantidade = nil
	m.addquantidade = nil
}

// SetPrecoUnitario sets the "preco_unitario" field.
func (m *ItemOrdemMutation) SetPrecoUnitario(f float64) {
	m.preco_unitario = &f
	m.addpreco_unitario = nil
}

// PrecoUnitario returns the value of the "preco_unitario" field in the mutation.
func (m *ItemOrdemMutation) PrecoUnitario() (r float64, exists bool) {
	v := m.preco_unitario
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecoUnitario returns the old "preco_unitario" field's value of the ItemOrdem entity.
// If the ItemOrdem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemOrdemMutation) OldPrecoUnitario(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecoUnitario is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecoUnitario requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecoUnitario: %w", err)
	}
	return oldValue.PrecoUnitario, nil
}

// AddPrecoUnitario adds f to the "preco_unitario" field.
func (m *ItemOrdemMutation) AddPrecoUnitario(f float64) {
	if m.addpreco_unitario != nil {
		*m.addpreco_unitario += f
	} else {
		m.addpreco_unitario = &f
	}
}

// AddedPrecoUnitario returns the value that was added to the "preco_unitario" field in this mutation.
func (m *ItemOrdemMutation) AddedPrecoUnitario() (r float64, exists bool) {
	v := m.addpreco_unitario
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrecoUnitario resets all changes to the "preco_unitario" field.
func (m *ItemOrdemMutation) ResetPrecoUnitario() {
	m.preco_unitario = nil
	m.addpreco_unitario = nil
}

// SetPrecoTotal sets the "preco_total" field.
func (m *ItemOrdemMutation) SetPrecoTotal(f float64) {
	m.preco_total = &f
	m.addpreco_total = nil
}

// PrecoTotal returns the value of the "preco_total" field in the mutation.
func (m *ItemOrdemMutation) PrecoTotal() (r float64, exists bool) {
	v := m.preco_total
	if v == nil {
		return
	}
	return *v, true
}

// OldPrecoTotal returns the old "preco_total" field's value of the ItemOrdem entity.
// If the ItemOrdem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemOrdemMutation) OldPrecoTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrecoTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrecoTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrecoTotal: %w", err)
	}
	return oldValue.PrecoTotal, nil
}

// AddPrecoTotal adds f to the "preco_total" field.
func (m *ItemOrdemMutation) AddPrecoTotal(f float64) {
	if m.addpreco_total != nil {
		*m.addpreco_total += f
	} else {
		m.addpreco_total = &f
	}
}

// AddedPrecoTotal returns the value that was added to the "preco_total" field in this mutation.
func (m *ItemOrdemMutation) AddedPrecoTotal() (r float64, exists bool) {
	v := m.addpreco_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrecoTotal resets all changes to the "preco_total" field.
func (m *ItemOrdemMutation) ResetPrecoTotal() {
	m.preco_total = nil
	m.addpreco_total = nil
}

// SetOrdemID sets the "ordem_id" field.
func (m *ItemOrdemMutation) SetOrdemID(i int) {
	m.ordem = &i
}

// OrdemID returns the value of the "ordem_id" field in the mutation.
func (m *ItemOrdemMutation) OrdemID() (r int, exists bool) {
	v := m.ordem
	if v == nil {
		return
	}
	return *v, true
}

// OldOrdemID returns the old "ordem_id" field's value of the ItemOrdem entity.
// If the ItemOrdem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemOrdemMutation) OldOrdemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrdemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrdemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrdemID: %w", err)
	}
	return oldValue.OrdemID, nil
}

// ResetOrdemID resets all changes to the "ordem_id" field.
func (m *ItemOrdemMutation) ResetOrdemID() {
	m.ordem = nil
}

// SetProdutoID sets the "produto_id" field.
func (m *ItemOrdemMutation) SetProdutoID(i int) {
	m.produto = &i
}

// ProdutoID returns the value of the "produto_id" field in the mutation.
func (m *ItemOrdemMutation) ProdutoID() (r int, exists bool) {
	v := m.produto
	if v == nil {
		return
	}
	return *v, true
}

// OldProdutoID returns the old "produto_id" field's value of the ItemOrdem entity.
// If the ItemOrdem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemOrdemMutation) OldProdutoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProdutoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProdutoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProdutoID: %w", err)
	}
	return oldValue.ProdutoID, nil
}

// ResetProdutoID resets all changes to the "produto_id" field.
func (m *ItemOrdemMutation) ResetProdutoID() {
	m.produto = nil
}

// ClearOrdem clears the "ordem" edge to the Ordem entity.
func (m *ItemOrdemMutation) ClearOrdem() {
	m.clearedordem = true
	m.clearedFields[itemordem.FieldOrdemID] = struct{}{}
}

// OrdemCleared reports if the "ordem" edge to the Ordem entity was cleared.
func (m *ItemOrdemMutation) OrdemCleared() bool {
	return m.clearedordem
}

// OrdemIDs returns the "ordem" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrdemID instead. It exists only for internal usage by the builders.
func (m *ItemOrdemMutation) OrdemIDs() (ids []int) {
	if id := m.ordem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrdem resets all changes to the "ordem" edge.
func (m *ItemOrdemMutation) ResetOrdem() {
	m.ordem = nil
	m.clearedordem = false
}

// ClearProduto clears the "produto" edge to the Produto entity.
func (m *ItemOrdemMutation) ClearProduto() {
	m.clearedproduto = true
	m.clearedFields[itemordem.FieldProdutoID] = struct{}{}
}

// ProdutoCleared reports if the "produto" edge to the Produto entity was cleared.
func (m *ItemOrdemMutation) ProdutoCleared() bool {
	return m.clearedproduto
}

// ProdutoIDs returns the "produto" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProdutoID instead. It exists only for internal usage by the builders.
func (m *ItemOrdemMutation) ProdutoIDs() (ids []int) {
	if id := m.produto; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduto resets all changes to the "produto" edge.
func (m *ItemOrdemMutation) ResetProduto() {
	m.produto = nil
	m.clearedproduto = false
}

// SetEnvioID sets the "envio" edge to the Envio entity by id.
func (m *ItemOrdemMutation) SetEnvioID(id int) {
	m.envio = &id
}

// ClearEnvio clears the "envio" edge to the Envio entity.
func (m *ItemOrdemMutation) ClearEnvio() {
	m.clearedenvio = true
}

// EnvioCleared reports if the "envio" edge to the Envio entity was cleared.
func (m *ItemOrdemMutation) EnvioCleared() bool {
	return m.clearedenvio
}

// EnvioID returns the "envio" edge ID in the mutation.
func (m *ItemOrdemMutation) EnvioID() (id int, exists bool) {
	if m.envio != nil {
		return *m.envio, true
	}
	return
}

// EnvioIDs returns the "envio" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvioID instead. It exists only for internal usage by the builders.
func (m *ItemOrdemMutation) EnvioIDs() (ids []int) {
	if id := m.envio; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvio resets all changes to the "envio" edge.
func (m *ItemOrdemMutation) ResetEnvio() {
	m.envio = nil
	m.clearedenvio = false
}

// Where appends a list predicates to the ItemOrdemMutation builder.
func (m *ItemOrdemMutation) Where(ps ...predicate.ItemOrdem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ItemOrdemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ItemOrdemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ItemOrdem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ItemOrdemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ItemOrdemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ItemOrdem).
func (m *ItemOrdemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemOrdemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.quantidade != nil {
		fields = append(fields, itemordem.FieldQuantidade)
	}
	if m.preco_unitario != nil {
		fields = append(fields, itemordem.FieldPrecoUnitario)
	}
	if m.preco_total != nil {
		fields = append(fields, itemordem.FieldPrecoTotal)
	}
	if m.ordem != nil {
		fields = append(fields, itemordem.FieldOrdemID)
	}
	if m.produto != nil {
		fields = append(fields, itemordem.FieldProdutoID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemOrdemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case itemordem.FieldQuantidade:
		return m.Quantidade()
	case itemordem.FieldPrecoUnitario:
		return m.PrecoUnitario()
	case itemordem.FieldPrecoTotal:
		return m.PrecoTotal()
	case itemordem.FieldOrdemID:
		return m.OrdemID()
	case itemordem.FieldProdutoID:
		return m.ProdutoID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemOrdemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case itemordem.FieldQuantidade:
		return m.OldQuantidade(ctx)
	case itemordem.FieldPrecoUnitario:
		return m.OldPrecoUnitario(ctx)
	case itemordem.FieldPrecoTotal:
		return m.OldPrecoTotal(ctx)
	case itemordem.FieldOrdemID:
		return m.OldOrdemID(ctx)
	case itemordem.FieldProdutoID:
		return m.OldProdutoID(ctx)
	}
	return nil, fmt.Errorf("unknown ItemOrdem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemOrdemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case itemordem.FieldQuantidade:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantidade(v)
		return nil
	case itemordem.FieldPrecoUnitario:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecoUnitario(v)
		return nil
	case itemordem.FieldPrecoTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrecoTotal(v)
		return nil
	case itemordem.FieldOrdemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrdemID(v)
		return nil
	case itemordem.FieldProdutoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProdutoID(v)
		return nil
	}
	return fmt.Errorf("unknown ItemOrdem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemOrdemMutation) AddedFields() []string {
	var fields []string
	if m.addquantidade != nil {
		fields = append(fields, itemordem.FieldQuantidade)
	}
	if m.addpreco_unitario != nil {
		fields = append(fields, itemordem.FieldPrecoUnitario)
	}
	if m.addpreco_total != nil {
		fields = append(fields, itemordem.FieldPrecoTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemOrdemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case itemordem.FieldQuantidade:
		return m.AddedQuantidade()
	case itemordem.FieldPrecoUnitario:
		return m.AddedPrecoUnitario()
	case itemordem.FieldPrecoTotal:
		return m.AddedPrecoTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemOrdemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case itemordem.FieldQuantidade:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantidade(v)
		return nil
	case itemordem.FieldPrecoUnitario:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecoUnitario(v)
		return nil
	case itemordem.FieldPrecoTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrecoTotal(v)
		return nil
	}
	return fmt.Errorf("unknown ItemOrdem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemOrdemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemOrdemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemOrdemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ItemOrdem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemOrdemMutation) ResetField(name string) error {
	switch name {
	case itemordem.FieldQuantidade:
		m.ResetQuantidade()
		return nil
	case itemordem.FieldPrecoUnitario:
		m.ResetPrecoUnitario()
		return nil
	case itemordem.FieldPrecoTotal:
		m.ResetPrecoTotal()
		return nil
	case itemordem.FieldOrdemID:
		m.ResetOrdemID()
		return nil
	case itemordem.FieldProdutoID:
		m.ResetProdutoID()
		return nil
	}
	return fmt.Errorf("unknown ItemOrdem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemOrdemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.ordem != nil {
		edges = append(edges, itemordem.EdgeOrdem)
	}
	if m.produto != nil {
		edges = append(edges, itemordem.EdgeProduto)
	}
	if m.envio != nil {
		edges = append(edges, itemordem.EdgeEnvio)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemOrdemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case itemordem.EdgeOrdem:
		if id := m.ordem; id != nil {
			return []ent.Value{*id}
		}
	case itemordem.EdgeProduto:
		if id := m.produto; id != nil {
			return []ent.Value{*id}
		}
	case itemordem.EdgeEnvio:
		if id := m.envio; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemOrdemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemOrdemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemOrdemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedordem {
		edges = append(edges, itemordem.EdgeOrdem)
	}
	if m.clearedproduto {
		edges = append(edges, itemordem.EdgeProduto)
	}
	if m.clearedenvio {
		edges = append(edges, itemordem.EdgeEnvio)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemOrdemMutation) EdgeCleared(name string) bool {
	switch name {
	case itemordem.EdgeOrdem:
		return m.clearedordem
	case itemordem.EdgeProduto:
		return m.clearedproduto
	case itemordem.EdgeEnvio:
		return m.clearedenvio
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemOrdemMutation) ClearEdge(name string) error {
	switch name {
	case itemordem.EdgeOrdem:
		m.ClearOrdem()
		return nil
	case itemordem.EdgeProduto:
		m.ClearProduto()
		return nil
	case itemordem.EdgeEnvio:
		m.ClearEnvio()
		return nil
	}
	return fmt.Errorf("unknown ItemOrdem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemOrdemMutation) ResetEdge(name string) error {
	switch name {
	case itemordem.EdgeOrdem:
		m.ResetOrdem()
		return nil
	case itemordem.EdgeProduto:
		m.ResetProduto()
		return nil
	case itemordem.EdgeEnvio:
		m.ResetEnvio()
		return nil
	}
	return fmt.Errorf("unknown ItemOrdem edge %s", name)
}

// OrdemMutation represents an operation that mutates the Ordem nodes in the graph.
type OrdemMutation struct {
	config
	op              Op
	typ             string
	id              *int
	data_ordem      *time.Time
	completa        *bool
	clearedFields   map[string]struct{}
	produtos        map[int]struct{}
	removedprodutos map[int]struct{}
	clearedprodutos bool
	clientes        *int
	clearedclientes bool
	items           map[int]struct{}
	removeditems    map[int]struct{}
	cleareditems    bool
	done            bool
	oldValue        func(context.Context) (*Ordem, error)
	predicates      []predicate.Ordem
}

var _ ent.Mutation = (*OrdemMutation)(nil)

// ordemOption allows management of the mutation configuration using functional options.
type ordemOption func(*OrdemMutation)

// newOrdemMutation creates new mutation for the Ordem entity.
func newOrdemMutation(c config, op Op, opts ...ordemOption) *OrdemMutation {
	m := &OrdemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrdem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrdemID sets the ID field of the mutation.
func withOrdemID(id int) ordemOption {
	return func(m *OrdemMutation) {
		var (
			err   error
			once  sync.Once
			value *Ordem
		)
		m.oldValue = func(ctx context.Context) (*Ordem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ordem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrdem sets the old Ordem of the mutation.
func withOrdem(node *Ordem) ordemOption {
	return func(m *OrdemMutation) {
		m.oldValue = func(context.Context) (*Ordem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrdemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrdemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrdemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrdemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ordem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDataOrdem sets the "data_ordem" field.
func (m *OrdemMutation) SetDataOrdem(t time.Time) {
	m.data_ordem = &t
}

// DataOrdem returns the value of the "data_ordem" field in the mutation.
func (m *OrdemMutation) DataOrdem() (r time.Time, exists bool) {
	v := m.data_ordem
	if v == nil {
		return
	}
	return *v, true
}

// OldDataOrdem returns the old "data_ordem" field's value of the Ordem entity.
// If the Ordem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdemMutation) OldDataOrdem(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataOrdem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataOrdem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataOrdem: %w", err)
	}
	return oldValue.DataOrdem, nil
}

// ResetDataOrdem resets all changes to the "data_ordem" field.
func (m *OrdemMutation) ResetDataOrdem() {
	m.data_ordem = nil
}

// SetCompleta sets the "completa" field.
func (m *OrdemMutation) SetCompleta(b bool) {
	m.completa = &b
}

// Completa returns the value of the "completa" field in the mutation.
func (m *OrdemMutation) Completa() (r bool, exists bool) {
	v := m.completa
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleta returns the old "completa" field's value of the Ordem entity.
// If the Ordem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdemMutation) OldCompleta(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleta: %w", err)
	}
	return oldValue.Completa, nil
}

// ResetCompleta resets all changes to the "completa" field.
func (m *OrdemMutation) ResetCompleta() {
	m.completa = nil
}

// AddProdutoIDs adds the "produtos" edge to the Produto entity by ids.
func (m *OrdemMutation) AddProdutoIDs(ids ...int) {
	if m.produtos == nil {
		m.produtos = make(map[int]struct{})
	}
	for i := range ids {
		m.produtos[ids[i]] = struct{}{}
	}
}

// ClearProdutos clears the "produtos" edge to the Produto entity.
func (m *OrdemMutation) ClearProdutos() {
	m.clearedprodutos = true
}

// ProdutosCleared reports if the "produtos" edge to the Produto entity was cleared.
func (m *OrdemMutation) ProdutosCleared() bool {
	return m.clearedprodutos
}

// RemoveProdutoIDs removes the "produtos" edge to the Produto entity by IDs.
func (m *OrdemMutation) RemoveProdutoIDs(ids ...int) {
	if m.removedprodutos == nil {
		m.removedprodutos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.produtos, ids[i])
		m.removedprodutos[ids[i]] = struct{}{}
	}
}

// RemovedProdutos returns the removed IDs of the "produtos" edge to the Produto entity.
func (m *OrdemMutation) RemovedProdutosIDs() (ids []int) {
	for id := range m.removedprodutos {
		ids = append(ids, id)
	}
	return
}

// ProdutosIDs returns the "produtos" edge IDs in the mutation.
func (m *OrdemMutation) ProdutosIDs() (ids []int) {
	for id := range m.produtos {
		ids = append(ids, id)
	}
	return
}

// ResetProdutos resets all changes to the "produtos" edge.
func (m *OrdemMutation) ResetProdutos() {
	m.produtos = nil
	m.clearedprodutos = false
	m.removedprodutos = nil
}

// SetClientesID sets the "clientes" edge to the Cliente entity by id.
func (m *OrdemMutation) SetClientesID(id int) {
	m.clientes = &id
}

// ClearClientes clears the "clientes" edge to the Cliente entity.
func (m *OrdemMutation) ClearClientes() {
	m.clearedclientes = true
}

// ClientesCleared reports if the "clientes" edge to the Cliente entity was cleared.
func (m *OrdemMutation) ClientesCleared() bool {
	return m.clearedclientes
}

// ClientesID returns the "clientes" edge ID in the mutation.
func (m *OrdemMutation) ClientesID() (id int, exists bool) {
	if m.clientes != nil {
		return *m.clientes, true
	}
	return
}

// ClientesIDs returns the "clientes" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClientesID instead. It exists only for internal usage by the builders.
func (m *OrdemMutation) ClientesIDs() (ids []int) {
	if id := m.clientes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClientes resets all changes to the "clientes" edge.
func (m *OrdemMutation) ResetClientes() {
	m.clientes = nil
	m.clearedclientes = false
}

// AddItemIDs adds the "items" edge to the ItemOrdem entity by ids.
func (m *OrdemMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the ItemOrdem entity.
func (m *OrdemMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the ItemOrdem entity was cleared.
func (m *OrdemMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the ItemOrdem entity by IDs.
func (m *OrdemMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the ItemOrdem entity.
func (m *OrdemMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *OrdemMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *OrdemMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the OrdemMutation builder.
func (m *OrdemMutation) Where(ps ...predicate.Ordem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrdemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrdemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ordem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrdemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrdemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ordem).
func (m *OrdemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrdemMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.data_ordem != nil {
		fields = append(fields, ordem.FieldDataOrdem)
	}
	if m.completa != nil {
		fields = append(fields, ordem.FieldCompleta)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrdemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordem.FieldDataOrdem:
		return m.DataOrdem()
	case ordem.FieldCompleta:
		return m.Completa()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrdemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordem.FieldDataOrdem:
		return m.OldDataOrdem(ctx)
	case ordem.FieldCompleta:
		return m.OldCompleta(ctx)
	}
	return nil, fmt.Errorf("unknown Ordem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrdemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordem.FieldDataOrdem:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataOrdem(v)
		return nil
	case ordem.FieldCompleta:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleta(v)
		return nil
	}
	return fmt.Errorf("unknown Ordem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrdemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrdemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrdemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ordem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrdemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrdemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrdemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ordem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrdemMutation) ResetField(name string) error {
	switch name {
	case ordem.FieldDataOrdem:
		m.ResetDataOrdem()
		return nil
	case ordem.FieldCompleta:
		m.ResetCompleta()
		return nil
	}
	return fmt.Errorf("unknown Ordem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrdemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.produtos != nil {
		edges = append(edges, ordem.EdgeProdutos)
	}
	if m.clientes != nil {
		edges = append(edges, ordem.EdgeClientes)
	}
	if m.items != nil {
		edges = append(edges, ordem.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrdemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordem.EdgeProdutos:
		ids := make([]ent.Value, 0, len(m.produtos))
		for id := range m.produtos {
			ids = append(ids, id)
		}
		return ids
	case ordem.EdgeClientes:
		if id := m.clientes; id != nil {
			return []ent.Value{*id}
		}
	case ordem.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrdemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedprodutos != nil {
		edges = append(edges, ordem.EdgeProdutos)
	}
	if m.removeditems != nil {
		edges = append(edges, ordem.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrdemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ordem.EdgeProdutos:
		ids := make([]ent.Value, 0, len(m.removedprodutos))
		for id := range m.removedprodutos {
			ids = append(ids, id)
		}
		return ids
	case ordem.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrdemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprodutos {
		edges = append(edges, ordem.EdgeProdutos)
	}
	if m.clearedclientes {
		edges = append(edges, ordem.EdgeClientes)
	}
	if m.cleareditems {
		edges = append(edges, ordem.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrdemMutation) EdgeCleared(name string) bool {
	switch name {
	case ordem.EdgeProdutos:
		return m.clearedprodutos
	case ordem.EdgeClientes:
		return m.clearedclientes
	case ordem.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrdemMutation) ClearEdge(name string) error {
	switch name {
	case ordem.EdgeClientes:
		m.ClearClientes()
		return nil
	}
	return fmt.Errorf("unknown Ordem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrdemMutation) ResetEdge(name string) error {
	switch name {
	case ordem.EdgeProdutos:
		m.ResetProdutos()
		return nil
	case ordem.EdgeClientes:
		m.ResetClientes()
		return nil
	case ordem.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown Ordem edge %s", name)
}

// ProdutoMutation represents an operation that mutates the Produto nodes in the graph.
type ProdutoMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	sku                 *string
	nome                *string
	quant_no_estoque    *int
	addquant_no_estoque *int
	clearedFields       map[string]struct{}
	ordens              map[int]struct{}
	removedordens       map[int]struct{}
	clearedordens       bool
	stock               *int
	clearedstock        bool
	itens               map[int]struct{}
	removeditens        map[int]struct{}
	cleareditens        bool
	done                bool
	oldValue            func(context.Context) (*Produto, error)
	predicates          []predicate.Produto
}

var _ ent.Mutation = (*ProdutoMutation)(nil)

// produtoOption allows management of the mutation configuration using functional options.
type produtoOption func(*ProdutoMutation)

// newProdutoMutation creates new mutation for the Produto entity.
func newProdutoMutation(c config, op Op, opts ...produtoOption) *ProdutoMutation {
	m := &ProdutoMutation{
		config:        c,
		op:            op,
		typ:           TypeProduto,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProdutoID sets the ID field of the mutation.
func withProdutoID(id int) produtoOption {
	return func(m *ProdutoMutation) {
		var (
			err   error
			once  sync.Once
			value *Produto
		)
		m.oldValue = func(ctx context.Context) (*Produto, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Produto.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduto sets the old Produto of the mutation.
func withProduto(node *Produto) produtoOption {
	return func(m *ProdutoMutation) {
		m.oldValue = func(context.Context) (*Produto, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProdutoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProdutoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProdutoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProdutoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Produto.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSku sets the "sku" field.
func (m *ProdutoMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *ProdutoMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Produto entity.
// If the Produto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdutoMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *ProdutoMutation) ResetSku() {
	m.sku = nil
}

// SetNome sets the "nome" field.
func (m *ProdutoMutation) SetNome(s string) {
	m.nome = &s
}

// Nome returns the value of the "nome" field in the mutation.
func (m *ProdutoMutation) Nome() (r string, exists bool) {
	v := m.nome
	if v == nil {
		return
	}
	return *v, true
}

// OldNome returns the old "nome" field's value of the Produto entity.
// If the Produto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdutoMutation) OldNome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNome: %w", err)
	}
	return oldValue.Nome, nil
}

// ResetNome resets all changes to the "nome" field.
func (m *ProdutoMutation) ResetNome() {
	m.nome = nil
}

// SetQuantNoEstoque sets the "quant_no_estoque" field.
func (m *ProdutoMutation) SetQuantNoEstoque(i int) {
	m.quant_no_estoque = &i
	m.addquant_no_estoque = nil
}

// QuantNoEstoque returns the value of the "quant_no_estoque" field in the mutation.
func (m *ProdutoMutation) QuantNoEstoque() (r int, exists bool) {
	v := m.quant_no_estoque
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantNoEstoque returns the old "quant_no_estoque" field's value of the Produto entity.
// If the Produto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdutoMutation) OldQuantNoEstoque(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantNoEstoque is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantNoEstoque requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantNoEstoque: %w", err)
	}
	return oldValue.QuantNoEstoque, nil
}

// AddQuantNoEstoque adds i to the "quant_no_estoque" field.
func (m *ProdutoMutation) AddQuantNoEstoque(i int) {
	if m.addquant_no_estoque != nil {
		*m.addquant_no_estoque += i
	} else {
		m.addquant_no_estoque = &i
	}
}

// AddedQuantNoEstoque returns the value that was added to the "quant_no_estoque" field in this mutation.
func (m *ProdutoMutation) AddedQuantNoEstoque() (r int, exists bool) {
	v := m.addquant_no_estoque
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantNoEstoque resets all changes to the "quant_no_estoque" field.
func (m *ProdutoMutation) ResetQuantNoEstoque() {
	m.quant_no_estoque = nil
	m.addquant_no_estoque = nil
}

// AddOrdenIDs adds the "ordens" edge to the Ordem entity by ids.
func (m *ProdutoMutation) AddOrdenIDs(ids ...int) {
	if m.ordens == nil {
		m.ordens = make(map[int]struct{})
	}
	for i := range ids {
		m.ordens[ids[i]] = struct{}{}
	}
}

// ClearOrdens clears the "ordens" edge to the Ordem entity.
func (m *ProdutoMutation) ClearOrdens() {
	m.clearedordens = true
}

// OrdensCleared reports if the "ordens" edge to the Ordem entity was cleared.
func (m *ProdutoMutation) OrdensCleared() bool {
	return m.clearedordens
}

// RemoveOrdenIDs removes the "ordens" edge to the Ordem entity by IDs.
func (m *ProdutoMutation) RemoveOrdenIDs(ids ...int) {
	if m.removedordens == nil {
		m.removedordens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ordens, ids[i])
		m.removedordens[ids[i]] = struct{}{}
	}
}

// RemovedOrdens returns the removed IDs of the "ordens" edge to the Ordem entity.
func (m *ProdutoMutation) RemovedOrdensIDs() (ids []int) {
	for id := range m.removedordens {
		ids = append(ids, id)
	}
	return
}

// OrdensIDs returns the "ordens" edge IDs in the mutation.
func (m *ProdutoMutation) OrdensIDs() (ids []int) {
	for id := range m.ordens {
		ids = append(ids, id)
	}
	return
}

// ResetOrdens resets all changes to the "ordens" edge.
func (m *ProdutoMutation) ResetOrdens() {
	m.ordens = nil
	m.clearedordens = false
	m.removedordens = nil
}

// SetStockID sets the "stock" edge to the Stock entity by id.
func (m *ProdutoMutation) SetStockID(id int) {
	m.stock = &id
}

// ClearStock clears the "stock" edge to the Stock entity.
func (m *ProdutoMutation) ClearStock() {
	m.clearedstock = true
}

// StockCleared reports if the "stock" edge to the Stock entity was cleared.
func (m *ProdutoMutation) StockCleared() bool {
	return m.clearedstock
}

// StockID returns the "stock" edge ID in the mutation.
func (m *ProdutoMutation) StockID() (id int, exists bool) {
	if m.stock != nil {
		return *m.stock, true
	}
	return
}

// StockIDs returns the "stock" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StockID instead. It exists only for internal usage by the builders.
func (m *ProdutoMutation) StockIDs() (ids []int) {
	if id := m.stock; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStock resets all changes to the "stock" edge.
func (m *ProdutoMutation) ResetStock() {
	m.stock = nil
	m.clearedstock = false
}

// AddItenIDs adds the "itens" edge to the ItemOrdem entity by ids.
func (m *ProdutoMutation) AddItenIDs(ids ...int) {
	if m.itens == nil {
		m.itens = make(map[int]struct{})
	}
	for i := range ids {
		m.itens[ids[i]] = struct{}{}
	}
}

// ClearItens clears the "itens" edge to the ItemOrdem entity.
func (m *ProdutoMutation) ClearItens() {
	m.cleareditens = true
}

// ItensCleared reports if the "itens" edge to the ItemOrdem entity was cleared.
func (m *ProdutoMutation) ItensCleared() bool {
	return m.cleareditens
}

// RemoveItenIDs removes the "itens" edge to the ItemOrdem entity by IDs.
func (m *ProdutoMutation) RemoveItenIDs(ids ...int) {
	if m.removeditens == nil {
		m.removeditens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.itens, ids[i])
		m.removeditens[ids[i]] = struct{}{}
	}
}

// RemovedItens returns the removed IDs of the "itens" edge to the ItemOrdem entity.
func (m *ProdutoMutation) RemovedItensIDs() (ids []int) {
	for id := range m.removeditens {
		ids = append(ids, id)
	}
	return
}

// ItensIDs returns the "itens" edge IDs in the mutation.
func (m *ProdutoMutation) ItensIDs() (ids []int) {
	for id := range m.itens {
		ids = append(ids, id)
	}
	return
}

// ResetItens resets all changes to the "itens" edge.
func (m *ProdutoMutation) ResetItens() {
	m.itens = nil
	m.cleareditens = false
	m.removeditens = nil
}

// Where appends a list predicates to the ProdutoMutation builder.
func (m *ProdutoMutation) Where(ps ...predicate.Produto) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProdutoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProdutoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Produto, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProdutoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProdutoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Produto).
func (m *ProdutoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProdutoMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.sku != nil {
		fields = append(fields, produto.FieldSku)
	}
	if m.nome != nil {
		fields = append(fields, produto.FieldNome)
	}
	if m.quant_no_estoque != nil {
		fields = append(fields, produto.FieldQuantNoEstoque)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProdutoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case produto.FieldSku:
		return m.Sku()
	case produto.FieldNome:
		return m.Nome()
	case produto.FieldQuantNoEstoque:
		return m.QuantNoEstoque()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProdutoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case produto.FieldSku:
		return m.OldSku(ctx)
	case produto.FieldNome:
		return m.OldNome(ctx)
	case produto.FieldQuantNoEstoque:
		return m.OldQuantNoEstoque(ctx)
	}
	return nil, fmt.Errorf("unknown Produto field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProdutoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case produto.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case produto.FieldNome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNome(v)
		return nil
	case produto.FieldQuantNoEstoque:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantNoEstoque(v)
		return nil
	}
	return fmt.Errorf("unknown Produto field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProdutoMutation) AddedFields() []string {
	var fields []string
	if m.addquant_no_estoque != nil {
		fields = append(fields, produto.FieldQuantNoEstoque)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProdutoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case produto.FieldQuantNoEstoque:
		return m.AddedQuantNoEstoque()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProdutoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case produto.FieldQuantNoEstoque:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantNoEstoque(v)
		return nil
	}
	return fmt.Errorf("unknown Produto numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProdutoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProdutoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProdutoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Produto nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProdutoMutation) ResetField(name string) error {
	switch name {
	case produto.FieldSku:
		m.ResetSku()
		return nil
	case produto.FieldNome:
		m.ResetNome()
		return nil
	case produto.FieldQuantNoEstoque:
		m.ResetQuantNoEstoque()
		return nil
	}
	return fmt.Errorf("unknown Produto field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProdutoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.ordens != nil {
		edges = append(edges, produto.EdgeOrdens)
	}
	if m.stock != nil {
		edges = append(edges, produto.EdgeStock)
	}
	if m.itens != nil {
		edges = append(edges, produto.EdgeItens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProdutoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case produto.EdgeOrdens:
		ids := make([]ent.Value, 0, len(m.ordens))
		for id := range m.ordens {
			ids = append(ids, id)
		}
		return ids
	case produto.EdgeStock:
		if id := m.stock; id != nil {
			return []ent.Value{*id}
		}
	case produto.EdgeItens:
		ids := make([]ent.Value, 0, len(m.itens))
		for id := range m.itens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProdutoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedordens != nil {
		edges = append(edges, produto.EdgeOrdens)
	}
	if m.removeditens != nil {
		edges = append(edges, produto.EdgeItens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProdutoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case produto.EdgeOrdens:
		ids := make([]ent.Value, 0, len(m.removedordens))
		for id := range m.removedordens {
			ids = append(ids, id)
		}
		return ids
	case produto.EdgeItens:
		ids := make([]ent.Value, 0, len(m.removeditens))
		for id := range m.removeditens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProdutoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedordens {
		edges = append(edges, produto.EdgeOrdens)
	}
	if m.clearedstock {
		edges = append(edges, produto.EdgeStock)
	}
	if m.cleareditens {
		edges = append(edges, produto.EdgeItens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProdutoMutation) EdgeCleared(name string) bool {
	switch name {
	case produto.EdgeOrdens:
		return m.clearedordens
	case produto.EdgeStock:
		return m.clearedstock
	case produto.EdgeItens:
		return m.cleareditens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProdutoMutation) ClearEdge(name string) error {
	switch name {
	case produto.EdgeStock:
		m.ClearStock()
		return nil
	}
	return fmt.Errorf("unknown Produto unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProdutoMutation) ResetEdge(name string) error {
	switch name {
	case produto.EdgeOrdens:
		m.ResetOrdens()
		return nil
	case produto.EdgeStock:
		m.ResetStock()
		return nil
	case produto.EdgeItens:
		m.ResetItens()
		return nil
	}
	return fmt.Errorf("unknown Produto edge %s", name)
}

// StockMutation represents an operation that mutates the Stock nodes in the graph.
type StockMutation struct {
	config
	op              Op
	typ             string
	id              *int
	data_movimento  *time.Time
	quantidade      *int
	addquantidade   *int
	clearedFields   map[string]struct{}
	produtos        map[int]struct{}
	removedprodutos map[int]struct{}
	clearedprodutos bool
	done            bool
	oldValue        func(context.Context) (*Stock, error)
	predicates      []predicate.Stock
}

var _ ent.Mutation = (*StockMutation)(nil)

// stockOption allows management of the mutation configuration using functional options.
type stockOption func(*StockMutation)

// newStockMutation creates new mutation for the Stock entity.
func newStockMutation(c config, op Op, opts ...stockOption) *StockMutation {
	m := &StockMutation{
		config:        c,
		op:            op,
		typ:           TypeStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockID sets the ID field of the mutation.
func withStockID(id int) stockOption {
	return func(m *StockMutation) {
		var (
			err   error
			once  sync.Once
			value *Stock
		)
		m.oldValue = func(ctx context.Context) (*Stock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStock sets the old Stock of the mutation.
func withStock(node *Stock) stockOption {
	return func(m *StockMutation) {
		m.oldValue = func(context.Context) (*Stock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDataMovimento sets the "data_movimento" field.
func (m *StockMutation) SetDataMovimento(t time.Time) {
	m.data_movimento = &t
}

// DataMovimento returns the value of the "data_movimento" field in the mutation.
func (m *StockMutation) DataMovimento() (r time.Time, exists bool) {
	v := m.data_movimento
	if v == nil {
		return
	}
	return *v, true
}

// OldDataMovimento returns the old "data_movimento" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldDataMovimento(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataMovimento is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataMovimento requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataMovimento: %w", err)
	}
	return oldValue.DataMovimento, nil
}

// ResetDataMovimento resets all changes to the "data_movimento" field.
func (m *StockMutation) ResetDataMovimento() {
	m.data_movimento = nil
}

// SetQuantidade sets the "quantidade" field.
func (m *StockMutation) SetQuantidade(i int) {
	m.quantidade = &i
	m.addquantidade = nil
}

// Quantidade returns the value of the "quantidade" field in the mutation.
func (m *StockMutation) Quantidade() (r int, exists bool) {
	v := m.quantidade
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantidade returns the old "quantidade" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldQuantidade(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantidade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantidade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantidade: %w", err)
	}
	return oldValue.Quantidade, nil
}

// AddQuantidade adds i to the "quantidade" field.
func (m *StockMutation) AddQuantidade(i int) {
	if m.addquantidade != nil {
		*m.addquantidade += i
	} else {
		m.addquantidade = &i
	}
}

// AddedQuantidade returns the value that was added to the "quantidade" field in this mutation.
func (m *StockMutation) AddedQuantidade() (r int, exists bool) {
	v := m.addquantidade
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantidade resets all changes to the "quantidade" field.
func (m *StockMutation) ResetQuantidade() {
	m.quantidade = nil
	m.addquantidade = nil
}

// AddProdutoIDs adds the "produtos" edge to the Produto entity by ids.
func (m *StockMutation) AddProdutoIDs(ids ...int) {
	if m.produtos == nil {
		m.produtos = make(map[int]struct{})
	}
	for i := range ids {
		m.produtos[ids[i]] = struct{}{}
	}
}

// ClearProdutos clears the "produtos" edge to the Produto entity.
func (m *StockMutation) ClearProdutos() {
	m.clearedprodutos = true
}

// ProdutosCleared reports if the "produtos" edge to the Produto entity was cleared.
func (m *StockMutation) ProdutosCleared() bool {
	return m.clearedprodutos
}

// RemoveProdutoIDs removes the "produtos" edge to the Produto entity by IDs.
func (m *StockMutation) RemoveProdutoIDs(ids ...int) {
	if m.removedprodutos == nil {
		m.removedprodutos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.produtos, ids[i])
		m.removedprodutos[ids[i]] = struct{}{}
	}
}

// RemovedProdutos returns the removed IDs of the "produtos" edge to the Produto entity.
func (m *StockMutation) RemovedProdutosIDs() (ids []int) {
	for id := range m.removedprodutos {
		ids = append(ids, id)
	}
	return
}

// ProdutosIDs returns the "produtos" edge IDs in the mutation.
func (m *StockMutation) ProdutosIDs() (ids []int) {
	for id := range m.produtos {
		ids = append(ids, id)
	}
	return
}

// ResetProdutos resets all changes to the "produtos" edge.
func (m *StockMutation) ResetProdutos() {
	m.produtos = nil
	m.clearedprodutos = false
	m.removedprodutos = nil
}

// Where appends a list predicates to the StockMutation builder.
func (m *StockMutation) Where(ps ...predicate.Stock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Stock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Stock).
func (m *StockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.data_movimento != nil {
		fields = append(fields, stock.FieldDataMovimento)
	}
	if m.quantidade != nil {
		fields = append(fields, stock.FieldQuantidade)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldDataMovimento:
		return m.DataMovimento()
	case stock.FieldQuantidade:
		return m.Quantidade()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stock.FieldDataMovimento:
		return m.OldDataMovimento(ctx)
	case stock.FieldQuantidade:
		return m.OldQuantidade(ctx)
	}
	return nil, fmt.Errorf("unknown Stock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stock.FieldDataMovimento:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataMovimento(v)
		return nil
	case stock.FieldQuantidade:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantidade(v)
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockMutation) AddedFields() []string {
	var fields []string
	if m.addquantidade != nil {
		fields = append(fields, stock.FieldQuantidade)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldQuantidade:
		return m.AddedQuantidade()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stock.FieldQuantidade:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantidade(v)
		return nil
	}
	return fmt.Errorf("unknown Stock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Stock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockMutation) ResetField(name string) error {
	switch name {
	case stock.FieldDataMovimento:
		m.ResetDataMovimento()
		return nil
	case stock.FieldQuantidade:
		m.ResetQuantidade()
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.produtos != nil {
		edges = append(edges, stock.EdgeProdutos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stock.EdgeProdutos:
		ids := make([]ent.Value, 0, len(m.produtos))
		for id := range m.produtos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprodutos != nil {
		edges = append(edges, stock.EdgeProdutos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case stock.EdgeProdutos:
		ids := make([]ent.Value, 0, len(m.removedprodutos))
		for id := range m.removedprodutos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprodutos {
		edges = append(edges, stock.EdgeProdutos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockMutation) EdgeCleared(name string) bool {
	switch name {
	case stock.EdgeProdutos:
		return m.clearedprodutos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Stock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockMutation) ResetEdge(name string) error {
	switch name {
	case stock.EdgeProdutos:
		m.ResetProdutos()
		return nil
	}
	return fmt.Errorf("unknown Stock edge %s", name)
}
